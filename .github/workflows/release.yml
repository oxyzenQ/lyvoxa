# =============================================================================
# LYVOXA RELEASE PIPELINE - PROFESSIONAL ORDERED BUILD
# =============================================================================
# Runs AFTER CI Pipeline completes successfully
# Order: Tag Push ‚Üí CI Pipeline ‚Üí Release Build ‚Üí AUR Sync
# Author: rezky_nightky

name: üåü Release

on:
  workflow_run:
    workflows: ["üîß CI Pipeline"]  # Wait for CI to complete
    types:
      - completed
  workflow_dispatch:
    inputs:
      version:
        description: "Release version (e.g., 3.0, 3.0.1)"
        required: true

permissions:
  contents: write
  security-events: write
  actions: read
  pull-requests: write
  checks: write

env:
  CARGO_TERM_COLOR: always
  PROJECT_NAME: lyvoxa

jobs:
  # =============================================================================
  # STEP 1: BUILD OPTIMIZED RELEASE
  # =============================================================================
  # Note: CI Pipeline runs first independently, this runs after CI completes
  build-release:
    name: 1Ô∏è‚É£ Build Optimized Release
    runs-on: ubuntu-latest
    # Only run if CI succeeded AND triggered by a tag (or manual trigger)
    if: |
      (github.event_name == 'workflow_run' && 
       github.event.workflow_run.conclusion == 'success' && 
       github.event.workflow_run.event == 'push' &&
       github.event.workflow_run.head_branch != 'main') ||
      github.event_name == 'workflow_dispatch'
    outputs:
      version: ${{ steps.set_version.outputs.version }}
      rel_tag: ${{ steps.set_version.outputs.rel_tag }}

    steps:
      - name: Determine release tag
        id: set_version
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            REL_TAG="${{ github.event.inputs.version }}"
          elif [ "${{ github.event_name }}" = "workflow_run" ]; then
            # Extract tag from the workflow_run event
            REL_TAG="${{ github.event.workflow_run.head_branch }}"
          else
            REL_TAG="${GITHUB_REF_NAME}"
          fi
          echo "REL_TAG=$REL_TAG" >> $GITHUB_ENV
          echo "rel_tag=$REL_TAG" >> $GITHUB_OUTPUT
          VERSION=$(echo "$REL_TAG" | sed 's/^v//')
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "üè∑Ô∏è  Release tag: $REL_TAG"
      - name: Checkout
        uses: actions/checkout@v5
        with:
          ref: ${{ env.REL_TAG }}  # Checkout the tag
          fetch-depth: 0

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: x86_64-unknown-linux-gnu

      - name: Build Optimized Binary
        run: |
          echo "üöÄ Building optimized release with LTO..."
          export RUSTFLAGS="-C opt-level=z -C lto=fat -C codegen-units=1 -C strip=symbols"
          cargo build --release --target x86_64-unknown-linux-gnu
          strip --strip-all target/x86_64-unknown-linux-gnu/release/$PROJECT_NAME

          echo ""
          echo "üìä Binary Analysis:"
          ls -lh target/x86_64-unknown-linux-gnu/release/$PROJECT_NAME
          file target/x86_64-unknown-linux-gnu/release/$PROJECT_NAME
          echo ""
          echo "‚úÖ Optimized release build completed"

      - name: Check GPG availability
        id: check_gpg
        run: |
          if [ -n "${{ secrets.GPG_PRIVATE_KEY }}" ]; then
            echo "gpg_available=true" >> $GITHUB_OUTPUT
            echo "‚úÖ GPG_PRIVATE_KEY secret is configured"
          else
            echo "gpg_available=false" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è  GPG_PRIVATE_KEY secret not found - signatures will be skipped"
          fi

      - name: Setup GPG
        if: steps.check_gpg.outputs.gpg_available == 'true'
        run: |
          echo "üîê Setting up GPG for signing..."
          echo "${{ secrets.GPG_PRIVATE_KEY }}" | gpg --batch --import
          gpg --list-secret-keys --keyid-format LONG
          echo "‚úÖ GPG key imported successfully"

      - name: Create Package
        run: |
          # Get version
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            VERSION="${{ github.event.inputs.version }}"
          else
            VERSION="${GITHUB_REF#refs/tags/}"
          fi

          VERSION=$(echo "$VERSION" | sed 's/^v//')
          ARTIFACT="$PROJECT_NAME-$VERSION-linux-amd64"

          # Create clean package structure
          mkdir -p $ARTIFACT/bin
          cp target/x86_64-unknown-linux-gnu/release/$PROJECT_NAME $ARTIFACT/bin/
          cp README.md LICENSE $ARTIFACT/
          cp docs/CHANGELOG.md $ARTIFACT/ 2>/dev/null || true

          # Create tarball
          tar -czf $ARTIFACT.tar.gz $ARTIFACT/

          # Generate SHA256 checksum
          sha256sum $ARTIFACT.tar.gz > $ARTIFACT.tar.gz.sha256

          echo "VERSION=$VERSION" >> $GITHUB_ENV
          echo "ARTIFACT=$ARTIFACT" >> $GITHUB_ENV

          echo "‚úÖ Package: $ARTIFACT.tar.gz ($(du -h $ARTIFACT.tar.gz | cut -f1))"

      - name: Sign Package (GPG - Full Verification Chain)
        if: steps.check_gpg.outputs.gpg_available == 'true'
        run: |
          echo "üîè Creating professional signature chain..."
          echo ""

          # Function to sign with or without passphrase
          sign_file() {
            local input="$1"
            local output="$2"
            local armor="$3"

            if [ -n "${{ secrets.GPG_PASSPHRASE }}" ]; then
              echo "${{ secrets.GPG_PASSPHRASE }}" | gpg --batch --yes --passphrase-fd 0 \
                --pinentry-mode loopback $armor --output "$output" --detach-sign "$input"
            else
              gpg --batch --yes $armor --output "$output" --detach-sign "$input"
            fi
          }

          # 1. Binary signature (.sig) - for packaging systems
          echo "üì¶ Creating binary signature (.sig)..."
          sign_file "$ARTIFACT.tar.gz" "$ARTIFACT.tar.gz.sig" ""

          # 2. ASCII-armored signature (.asc) - for humans & GitHub
          echo "üìú Creating ASCII-armored signature (.asc)..."
          sign_file "$ARTIFACT.tar.gz" "$ARTIFACT.tar.gz.asc" "--armor"

          # 3. Sign SHA256 checksum (full chain of trust)
          echo "üîê Signing SHA256 checksum..."
          sign_file "$ARTIFACT.tar.gz.sha256" "$ARTIFACT.tar.gz.sha256.asc" "--armor"

          echo ""
          echo "‚úÖ Signature Suite Created:"
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          ls -lh $ARTIFACT.tar.gz* | awk '{print "  " $9 " (" $5 ")"}'
          echo ""

          # Verify all signatures
          echo "üîç Verifying signatures..."
          echo ""

          if gpg --verify $ARTIFACT.tar.gz.sig $ARTIFACT.tar.gz 2>&1 | grep "Good signature"; then
            echo "‚úÖ Binary signature (.sig) valid"
          fi

          if gpg --verify $ARTIFACT.tar.gz.asc $ARTIFACT.tar.gz 2>&1 | grep "Good signature"; then
            echo "‚úÖ ASCII signature (.asc) valid"
          fi

          if gpg --verify $ARTIFACT.tar.gz.sha256.asc $ARTIFACT.tar.gz.sha256 2>&1 | grep "Good signature"; then
            echo "‚úÖ SHA256 signature (.sha256.asc) valid"
          fi

          echo ""
          echo "üéØ Professional Release Suite Complete:"
          echo "  üì¶ $ARTIFACT.tar.gz (binary)"
          echo "  üîê $ARTIFACT.tar.gz.sha256 (integrity)"
          echo "  ü§ñ $ARTIFACT.tar.gz.sig (machine signature)"
          echo "  üìú $ARTIFACT.tar.gz.asc (human signature)"
          echo "  ‚úÖ $ARTIFACT.tar.gz.sha256.asc (signed hash)"

      - name: Skip GPG Signing Notice
        if: steps.check_gpg.outputs.gpg_available != 'true'
        run: |
          echo "‚ö†Ô∏è  GPG signing skipped - GPG_PRIVATE_KEY secret not configured"
          echo "üì¶ Release will only include:"
          echo "  - $ARTIFACT.tar.gz (binary)"
          echo "  - $ARTIFACT.tar.gz.sha256 (checksum)"
          echo ""
          echo "‚ÑπÔ∏è  To enable GPG signatures, add GPG_PRIVATE_KEY to repository secrets"

      - name: Generate Changelog
        run: |
          PREV_TAG=$(git describe --tags --abbrev=0 $(git rev-list --tags --skip=1 --max-count=1) 2>/dev/null || echo "")

          if [ -z "$PREV_TAG" ]; then
            echo "## Changes" > CHANGELOG.txt
            git log --oneline --pretty="- %s (%h)" -20 >> CHANGELOG.txt
          else
            echo "## Changes since $PREV_TAG" > CHANGELOG.txt
            git log $PREV_TAG..HEAD --oneline --pretty="- %s (%h)" >> CHANGELOG.txt
          fi

      - name: Create Release Notes
        run: |
          cat > RELEASE_NOTES.md << 'EOF'
          # LYVOXA
          ### System Monitor ¬∑ Born from Shadows

          > *"In the depths of your system, where processes whisper and metrics dance,*  
          > *Lyvoxa watches. Silent. Precise. Unstoppable."*

          ---

          ## üåë What's New in This Release

          EOF
          cat CHANGELOG.txt >> RELEASE_NOTES.md

          cat >> RELEASE_NOTES.md << EOF

          ---

          ## üîê The Seal of Trust

          > Every byte signed. Every hash verified. Trust through mathematics.

          <details>
          <summary><b>üîç Quick Integrity Check</b></summary>

          \`\`\`bash
          # Verify the SHA256 fingerprint
          sha256sum -c $ARTIFACT.tar.gz.sha256
          \`\`\`

          **Expected:** ‚úÖ OK

          </details>

          <details>
          <summary><b>üóùÔ∏è Full Cryptographic Verification</b></summary>

          **Step 1: Summon the Key** *(one-time ritual)*
          \`\`\`bash
          gpg --keyserver hkps://keys.openpgp.org --recv-keys 0D8D13BB989AF9F0
          \`\`\`

          **Step 2: Verify the Signature**
          \`\`\`bash
          # Machine signature (for automation)
          gpg --verify $ARTIFACT.tar.gz.sig $ARTIFACT.tar.gz

          # Human signature (ASCII-armored)
          gpg --verify $ARTIFACT.tar.gz.asc $ARTIFACT.tar.gz

          # Chain of trust (signed checksum)
          gpg --verify $ARTIFACT.tar.gz.sha256.asc $ARTIFACT.tar.gz.sha256
          sha256sum -c $ARTIFACT.tar.gz.sha256
          \`\`\`

          **Blessed Output:**
          \`\`\`
          gpg: Good signature from "Rezky Cahya Sahputra (Investor) <with.rezky@gmail.com>"
          Primary key fingerprint: 3495 ABF0 957D 28A7 E850  1375 0D8D 13BB 989A F9F0
          \`\`\`

          </details>

          ---

          ## üì¶ Artifacts Manifest

          | File | Purpose | Size |
          |------|---------|------|
          | \`$ARTIFACT.tar.gz\` | Binary distribution | ~ |
          | \`$ARTIFACT.tar.gz.sha256\` | Integrity checksum | 64 bytes |
          | \`$ARTIFACT.tar.gz.sig\` | GPG signature (binary) | ~ |
          | \`$ARTIFACT.tar.gz.asc\` | GPG signature (ASCII) | ~ |
          | \`$ARTIFACT.tar.gz.sha256.asc\` | Signed checksum | ~ |

          ---

          <div align="center">

          **Installation via AUR:**  
          \`yay -S lyvoxa-bin\` or \`paru -S lyvoxa-bin\`

          **Full Timeline:** [View all commits](${{ github.server_url }}/${{ github.repository }}/commits/$VERSION)

          *Crafted with precision ¬∑ Secured with cryptography*

          </div>
          EOF

      - name: Upload release artifacts
        uses: actions/upload-artifact@v4
        with:
          name: lyvoxa-release-artifacts-${{ github.sha }}
          path: |
            ${{ env.ARTIFACT }}.tar.gz
            ${{ env.ARTIFACT }}.tar.gz.sha256
            ${{ env.ARTIFACT }}.tar.gz.sig
            ${{ env.ARTIFACT }}.tar.gz.asc
            ${{ env.ARTIFACT }}.tar.gz.sha256.asc
            RELEASE_NOTES.md
          retention-days: 1

  # =============================================================================
  # STEP 2: PUBLISH RELEASE
  # =============================================================================
  publish:
    name: 2Ô∏è‚É£ Publish Release
    runs-on: ubuntu-latest
    needs: build-release
    permissions:
      contents: write

    steps:
      - name: Download release artifacts
        uses: actions/download-artifact@v5
        with:
          name: lyvoxa-release-artifacts-${{ github.sha }}
          path: ./release/

      - name: Prepare release files
        run: |
          cd release
          echo "üìã Files to publish:"
          ls -lh

      - name: Publish to GitHub Releases
        uses: softprops/action-gh-release@v2
        with:
          name: "Lyvoxa ${{ needs.build-release.outputs.rel_tag }}"
          tag_name: ${{ needs.build-release.outputs.rel_tag }}
          body_path: release/RELEASE_NOTES.md
          draft: false
          prerelease: false
          make_latest: true
          files: release/*
          fail_on_unmatched_files: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Release Summary
        run: |
          echo "‚úÖ Release ${{ github.ref_name }} published successfully"
          echo "üì¶ Artifacts uploaded to GitHub Releases"
          echo "üîó https://github.com/oxyzenQ/lyvoxa/releases/tag/${{ github.ref_name }}"

